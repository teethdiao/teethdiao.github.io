---
layout: post
title: Linux与Debian基本知识
category: Linux
tags: [Linux]
---

## 参考资料

《⻦哥的Linux私房菜》

[知乎教程](https://zhuanlan.zhihu.com/p/529736394)

[CSDN教程](https://blog.csdn.net/m0_47696151/article/details/119703623)

[vim和vi教程](https://blog.csdn.net/m0_51111980/article/details/123769265)

[shell教程](https://blog.csdn.net/xueshenlaila/article/details/122041530)



## 安装说明



[安装参考](https://blog.csdn.net/networkTalent/article/details/123375048)



这里使用的是运用虚拟机进行安装

就避免了安装双系统的各种麻烦



使用了[VMware Station](https://so.csdn.net/so/search?q=vmware&spm=1001.2101.3001.7020)的绿化版。

按上述安装步骤就可以使用了







## apt和dpkg





### 二者介绍



​	虽然使用源代码进行软件编译可以具有定制化的设置，但对于Linux distribution的发行商来说，则有软件管理不晚的问题，毕竟不是每个人都会进行源代码编译的。这个问题将会严重的影响linux平台上软件的发行与推广。

​    为了解决上述的问题，厂商先在他们的系统上面编译好了我们用户所需要的软件，然后将这个编译好并可执行的软件直接发布给用户安装。不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： Debian 的”.deb”，和 Red Hat的”.rpm”。也有一些重要的例外，比方说 Gentoo， Slackware，和 Foresight，但大多数会使用这两个基本系统中的一个。

​    Debian系列发行版了dpkg与apt-*的详细使用方法。pkg和apt都是debian的包管理工具dpkg侧重于本地软件的管理，apt基于dpkg，侧重于远程包的下载和依赖管理，为dpkg的前端。





### 主要区别

dpkg 仅用于安装本地的软件包，安装时不会安装依赖包，不解决依赖问题。

~~~linux
sudo dpkg -i <package_name>.deb
~~~





apt会默认从远程仓库搜索包的名字，下载并安装，并**同时安装依赖包**，以解决依赖问题

~~~linux
sudo apt install <package_name>
~~~

 



使用apt从本地安装，需要在包名前指定路径，否则只从远程仓库查找

~~~linux
sudo apt install <path>/<package_name>.deb
~~~





### dpkg的常用命令





* 查看指定包版本，架构和描述信息

  ~~~linux
  dpkg -l<package_name>
  dpkg -list<package_name>
  ~~~

* 列出已经安装的包，和版本，架构

  ~~~linux
  dpkg -l
  ~~~

* 查看包的安装路径

  ~~~
  dpkg -L<package_name>
  ~~~

* 查看包是否安装

  ~~~
  dpkg -s<package_name>；
  dpkg --status<package_name>；
  ~~~






### apt常用命令

更新包信息

~~~linux
sudo apt update
~~~



根据包信息升级

~~~
sudo apt upgrade
~~~



安装包

~~~
sudo apt install <package_name>
~~~





## linux基本语法



### ls

```linux
ls [选项] [目录或者文件]
```

功能 :

> 对于目录, 该命令会列出目录下所有子目录与文件.
> 对于文件, 该命令会列出文件名以及其他信息.

选项 :

> -a 列出目录下的所有文件，包括以 . 开头的隐含文件。
> -d 将目录象文件一样显示，而不是显示其下的文件。 如：ls –d 指定目录
> -k 以 k 字节的形式表示文件的大小。ls –alk 指定文件
> -l 列出文件的详细信息。
> -r 对目录反向排序。
> -t 以时间排序。
> -R 列出所有子目录下的文件。(递归)





### pwd

语法 :

```text
pwd
```

功能 :

> 查看当前所在的目录是什么





### cd

语法 :

```text
cd [目录名]
```

功能 :

> 能够切换当前目录.

注意 :

> / 称为根目录
> . 称为当前目录
> .. 称为当前目录的上级目录
> cd ..: 返回上级目录
> cd ~：进入用户家目
> cd -：返回最近访问目录





### touch

语法 :

```text
touch [选项] ... 文件 ...
```

功能 :

> touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的文件





### cat

语法 :

```text
cat [选项] [文件]
```

功能 :

> 查看文件的内容

选项 -n 能输出内容对应的行号





### echo

语法 :

```text
echo 内容 > 文件名
```

功能 :

> 将内容写到当前文件内





### mkdir

语法 :

```text
mkdir [选项] 目录名...
```

功能 :

```text
在当前目录下创建一个目录.
```

加上 选项 -p 可以创建多级目录





### rm

语法 :

```text
rm [选项] [文件或目录]
```

功能 :

> 删除指定的目录或者文件

常用选项 :

> -f 即使文件属性为只读(即写保护)，亦直接删除
> -i 删除前逐一询问确认
> -r 删除目录及其下所有文件

注意事项

> rm -rf / 不能使用.千万不能使用,后果自负~



### cp

语法 :

```text
cp [选项] 源文件或目录 目标文件或目录
```

功能 :

> 复制一个文件或目录

常用选项 :

> -f 或 --force 强行复制文件或目录， 不论目的文件或目录是否已经存在
> -i 或 --interactive 覆盖文件之前先询问用户
> -r递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理
> -R 或 --recursive递归处理，将指定目录下的文件及子目录一并处理







### mv



语法 :

```text
mv [选项] 源文件或目录 目标文件或目录
```

功能 :

> 移动一个文件或者目录

常用的选项 :

> -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
> -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！







### man

语法 :

```text
man 命令
```

功能 :

> 查看命令帮助手册







### less

语法 :

```text
less [参数] 文件
```

功能 :

> 查看文件内容.可以翻页





### head

语法 :

```text
head [参数] 文件
```

功能 :

> 查看文件的开头





### tail



语法 :

```text
tail [参数] 文件
```

功能 :

> 查看文件的末尾







### grep

语法 :

```text
grep [参数] [文件]
```

功能 :

> 用于查找文件中是否包含指定字符串,并显示对应的行

常用选项 :

1. -n<行数> 显示的行数
2. -w 全字匹配. 要求整个单词都完全相同的结果才能匹配出来, 而不仅仅是一个单词的一部分.
3. -r 递归查找. 可以搜索多级目录下的所有文件.
4. --color 高亮查找到的结果
5. --include 指定查找某些文件
6. --exclude 指定排除某些文件



### ps

语法 :

```text
ps [参数]
```

功能 :

> 查看当前系统中的进程

示例 :

```text
ps aux # 显示系统上所有的进程
ps aux | grep "进程名"
ps aux | grep "进程id"
```







### netstat



语法 :

```text
netstat [参数]
```

功能 :

> 查看当前的网络状态

示例 :

1. netstat -anp
2. netstat -anp | grep "进程名"
3. netstat -anp | grep "端口号"





## vim/vi工具使用



### 简介

vi编辑器是Linux和Unix的基本文本编辑器，工作在字符模式下。由于不需要图形界面，vi 是效率很高的文本编辑器。尽管在 Linux 上也有很多图形界面的编辑器可用，但 vi 在系统和服务器管理中的功能是那些图形编辑器所无法比拟的。vim 是 vi 的增强版，比 vi 更容易使用。vi 的命令几乎全部都可以在 vim 上使用。





### vi和vim三种常见模式



* **一般模式** ：以 vi/vim 命令打开一个档案就直接进入一般模式了 (这是默认的模式) 。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』快捷键来处理档案内容，也可以使用『复制、贴上』快捷键来处理你的文件数据。

* **编辑模式** ：按下i、I、o、O、a、A、r、R 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可。

* **命令行模式** ：在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim 、显示行号等的动作则是在此模式中达成的。使用==:或者/==进入



### 常用快捷键



* 一般模式拷贝当前行 ：yy ， 拷贝当前行向下的5行 ：5yy ，并粘贴 ： p 。

* 一般模式删除当前行 ： dd ，删除当前行向下的5行 ： 5dd 。

* 一般模式下，在文件中查找某个单词 ：[ 命令模式下： / 关键字，回车查找，输入 n 就是查找下一个 ]。

* 一般模式下，使用快捷键到达文档的最首行 ：gg 和 最末行 ： G 。

* 一般模式下，在一个文件中输入"xxxx" ，然后又撤销这个动作 ： u 。

* 一般模式下，并将光标移动到10行 ：shift+g
  第一步 ：输入10
  第二步 ：输入shift+g
  第三步 ：回车

* 命令行模式下，设置文件的行号，取消文件的行号 ：[ 命令模式下 : set nu 和 : set nonu]。
  
  







## shell 工具使用



### 什么是shell

Shell是一个命令解释器，它在操作系统的最外层，负责直接与用户进行对话，把用户的输入解释给操作系统，并处理各种各样的操作系统的输出结果，输出到屏幕反馈给用户。这种对话方式可以是交互式也可以是非交互式的

>  我们所输入的命令计算机是不识别的，这时就需要一种程序来帮助我们进行翻译，变成计算机能识别的二进制程序，同时又把计算机生成的结果返回给我们。



shell有很多种，

包括了==sh,csh,bash,tcsh,zsh==

我们常用的是**bash**





* 查看当前使用的bash

  ~~~
  echo $SHELL
  ~~~





### 什么是shell脚本



shell脚本：就是说我们把原来linux命令或语句放在一个文件中，然后通过这个程序文件去执行时，我们就说这个程序为shell脚本或shell程序；我们可以在脚本中输入一系列的命令以及相关的语法语句组合，比如变量，流程控制语句等，把他们有机结合起来就形成了一个功能强大的shell脚本。





### 基本shell 脚本





#### 基本使用流程



* 定义一个文件

  ~~~
  vim test.sh
  ~~~

* 写入以下内容

  ~~~
  !/bin/bash
  # This is Shell
  echo "hello word"
  mkdir /temp/test
  touch /tmp/test/a.txt
  ~~~

  > !/bin/bash 告知使用什么编辑器
  >
  > \# 代表注释

* 测试语法错误

  ~~~
  bash -x 文件名
  ~~~

* 执行文件

  ~~~
  bash 文件名
  source 文件名
  ~~~

  



#### shell变量



变量可以分成四类



* **用户变量**

  ~~~
  var1=123
  ~~~

  > 两边不能有空格
  >
  > 

* **环境变量**：这种变量中主要保存的是和系统操作环境相关的数据。

  * 局部变量：只在一个进程中使用

  * 全局变量：使用了export就可以到全局使用（*即所有bash都可得到这个变量*）

    ~~~
    export var1=www
    ~~~

    输入vim文件a.sh

    ~~~
    # !/bin/bash
    echo $var1
    ~~~

    执行文件

    ~~~
    bash a.sh
    ~~~

    可以得到var1的值

  * 永久变量

    把定义好的变量写进配置文件，就使其永久生效。

    这利用了连接启动bash进程，就会加载如下四个文件：*/etc/profile,etc/bashrc/,/root/.bashrc,/root/.bash_profile*

    下面插入永久变量

    ~~~
    vim /etc/profile
    export var1=xuegod
    source /etc/profile
    ~~~

  * **Path环境变量**

    > Shell要执行某个程序，要在系统中去搜索这个程序的路径，PATH变量用来定义命令和查找命令的目录。

    ~~~
    echo $PATH
    PATH=/pot/:$PATH
    
    ~~~

    *本行将/pot/放入PATH中*

    

    

    

* **位置参数变量**：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。\$1 \$2 …

  > Shell解释执行用户的命令时，将命令行的第一个字符作为命令名，而其它字符作为参数

  

* **预定义变量**：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。

  | 变量名 | 含义               |
  | ------ | ------------------ |
  | $*     | 显示所有脚本参数   |
  | $#     | 传递到脚本参数个数 |
  | $$     | 当前PID            |
  | $?     | 最后命令退出状态   |





### I/O重定向

通常来说, shell的接收键盘的输入, 然后处理, 并且将处理结果显示在屏幕上. 因此, 键盘输入被称为是 “标准输入”; 屏幕输出被称为是 “标准输出”. 然而我们可以改变shell获得输入的方式, 使其不仅是从键盘获取输入. 同时, 我们也可以改变shell输出的对象, 使其不只是输出在屏幕上.



当我们在shell中, 通过键盘输入命令, 就会得到输出
输出分为两种, 一种是命令的 运行结果, 一种是命令的 状态和错误信息
实际上, 我们的输入和shell的输出都会存储在文件中

键盘的输入存储在 标准输入文件中
shell的输出分别存储在 标准输出文件(运行结果) 和 标准错误文件(状态和错误信息)
注意, 这三种文件不会被保存在磁盘文件中
标准输入文件和键盘链接
标准输出文件和标准错误文件和屏幕链接
不过, 我们可以改变输入内容的来源 和 输出内容的目的地, 这也就是重定向
标准输出重定向
利用标准输出重定向操作符">“和”>>"







==>的重定向==

~~~
命令 > 输出文件
ls -l /usr/bin > ls-output.txt
~~~

> 自己设定输出文件
>
> - 如果你所给定的文件存在, 那么>将会输出 **从头开始** 覆盖该文件
> - 如果你多给的文件不存在, 那么>将会创建该文件



==>>的重定向==

~~~
命令 >> 输出文件
ls -l /usr/bin > ls-output.txt
~~~



- 如果你所给定的文件存在, 那么>将会输出 **从尾开始** 覆盖该文件
- 如果你多给的文件不存在, 那么>将会创建该文件
  **标准错误重定向**

